# Заметки по проекту

## Статус и проблемы

Проект предназначен для записи видео сеансов выбранного окна в файл.
В ходе разработки были испробованы следующие подходы и возникли следующие проблемы:

1.  **VidGear (ScreenGear + WriteGear)**:
    *   **Проблема**: Не удалось запустить из-за ошибок импорта `vidgear` или его зависимостей (например, `cv2`) в окружении пользователя. Многочисленные попытки переустановки не увенчались успехом.
    *   **Вывод**: Подход был оставлен из-за нестабильности установки/работы в целевом окружении.

2.  **MSS + FFmpeg-Python (прямая передача кадров)**:
    *   **Реализация**: Захват области экрана с помощью `mss` и передача кадров в `ffmpeg` (через `ffmpeg-python`) по `stdin`.
    *   **Проблема 1 (Потоки и MSS)**: `mss` использует `threading.local()` для своих ресурсов, что вызвало `AttributeError` (`'_thread._local' object has no attribute 'srcdc' / 'bmp'`), когда экземпляр `mss` создавался в одном потоке, а использовался (`.grab()`, `.close()`) в другом.
        *   **Решение**: Экземпляр `mss` теперь создается и используется строго в одном и том же потоке (`_recording_loop` в `FFmpegRecorder`).
    *   **Проблема 2 (Некорректные координаты окна)**: При сворачивании окна `get_window_geometry` возвращала координаты типа `-32000`, что приводило к ошибкам `mss` или `ffmpeg` (Invalid argument).
        *   **Решение**: Добавлена логика `_ensure_window_restored_and_get_geometry` для попыток восстановления окна и проверки геометрии перед запуском `ffmpeg`.
    *   **Проблема 3 (FFmpeg не завершается / timeout)**: После остановки передачи кадров (закрытия `stdin`), процесс `ffmpeg` не всегда завершался самостоятельно в течение разумного времени, что приводило к его принудительному `kill()` и потенциально поврежденным файлам.
        *   **Предположение**: Связано с обработкой аудиопотока `dshow` или общей буферизацией `ffmpeg`.
        *   **Текущее тестирование**: Пробуем запись без аудио и увеличили таймаут ожидания `ffmpeg`.
    *   **Проблема 4 (Захват экрана вместо окна)**: `mss.grab(monitor_coords)` захватывает прямоугольную область экрана, а не содержимое конкретного окна, если оно перекрыто. Это не соответствует требованию задачи.

3.  **GDI (PrintWindow) + FFmpeg-Python**:
    *   **Текущий подход**: Захват кадра окна с помощью функции Windows API `PrintWindow` (через `pywin32` и `ctypes`), которая должна захватывать содержимое окна, даже если оно перекрыто. Кадры передаются в `ffmpeg-python`.
    *   **Проблема 1 (Ошибка `CreateCompatibleBitmap`)**: При инициализации GDI-ресурсов возникает ошибка `[FrameGrabberGDI] Не удалось создать CreateCompatibleBitmap (...). Ошибка: 0`. `GetLastError()` возвращает 0, что затрудняет диагностику. Это происходит при попытке создать битмап, совместимый с DC окна "Яндекс Телемост".
        *   **Предположение**: Окно "Яндекс Телемост" использует методы рендеринга, несовместимые со стандартным созданием GDI битмапа на основе его DC, или DC окна имеет ограничения.
        *   **Попытка исправления**: Изменен способ создания битмапа в `WindowFrameGrabberGDI` — теперь он создается совместимым с DC рабочего стола, а не DC целевого окна. Это более надежный способ получить валидный битмап, на который `PrintWindow` затем должен отрисовать содержимое окна.
    *   **Проблема 2 (`AttributeError: 'PyCBitmap' object has no attribute 'GetSafeHandle'`)**: Возникала при очистке ресурсов, вероятно, как следствие неудачной инициализации битмапа.
        *   **Надежда**: Улучшенная инициализация и проверка в `WindowFrameGrabberGDI` должна решить это.

**Общее состояние:**
Задача оказалась значительно сложнее, чем "базовая простая задача", из-за необходимости надежно захватывать произвольные окна Windows, которые могут использовать различные технологии рендеринга, и корректно взаимодействовать с `ffmpeg` для кодирования. Многие "готовые решения" либо имеют свои сложности с установкой/настройкой (`VidGear`), либо требуют аккуратной низкоуровневой работы с системными API (`PrintWindow`, `ffmpeg` через `pipe`).

**Дальнейшие шаги, если текущий GDI-подход не сработает для "Яндекс Телемост":**

*   **Windows Graphics Capture API (WGC)**: Это современный API в Windows 10/11 для захвата окон. Он более надежен для современных приложений и работает с перекрытыми окнами. Однако его прямая реализация на Python с `ctypes` или `winsdk` (без `VidGear`) достаточно сложна и требует глубокого понимания COM и DirectX. `VidGear` использует WGC в одном из своих бэкендов (`ScreenGear` с опцией `backend="windows_graphics_capture"`), но мы столкнулись с проблемами установки `VidGear`.
*   **Альтернативные библиотеки для захвата окна**: Существуют и другие библиотеки, но они могут иметь свои ограничения или зависимости.
*   **Более глубокая отладка `PrintWindow`**: Если `PrintWindow` возвращает черный экран или некорректное изображение для "Яндекс Телемост", это подтвердит, что окно несовместимо с этим методом.
*   **Захват всего экрана и обрезка по координатам окна (как крайняя мера)**: Это вернет нас к проблеме перекрытых окон, но если окно всегда наверху и не перекрыто, это может быть временным решением, хотя и не идеальным.

**Вывод:**
На данный момент я не смог предоставить решение, которое бы "работало из коробки без проблем" для всех сценариев и типов окон, учитывая предыдущие трудности с зависимостями и сложность задачи захвата современных окон. Текущая попытка с `PrintWindow` и созданием битмапа, совместимого с Desktop DC, — это еще один шаг в отладке GDI-подхода.